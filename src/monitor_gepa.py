#!/usr/bin/env python3
"""
GEPA Optimization Monitor

Watches training logs and creates a clean summary of:
- Task PASS/FAIL results
- Prompts generated by GEPA
- Generation-by-generation progress
"""

import time
import re
import sys
import os
from datetime import datetime
from pathlib import Path

SUMMARY_FILE = "gepa_results/logs/optimization_summary.log"

class GEPAMonitor:
    def __init__(self, log_source):
        self.log_source = log_source
        self.current_generation = 0
        self.current_prompt = ""
        self.task_results = []  # [(task_id, pass/fail)]
        self.generation_scores = []  # [(gen, passed, total)]

        # Ensure summary dir exists
        Path(SUMMARY_FILE).parent.mkdir(parents=True, exist_ok=True)

        # Clear/init summary file
        with open(SUMMARY_FILE, 'w') as f:
            f.write(f"GEPA Optimization Summary\n")
            f.write(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"=" * 60 + "\n\n")

    def log_summary(self, msg):
        """Write to both console and summary file."""
        print(msg)
        with open(SUMMARY_FILE, 'a') as f:
            f.write(msg + "\n")

    def on_generation_start(self, gen_num):
        if self.current_generation > 0 and self.task_results:
            self._flush_generation_summary()

        self.current_generation = gen_num
        self.task_results = []
        self.log_summary(f"\n{'=' * 60}")
        self.log_summary(f"GENERATION {gen_num}")
        self.log_summary(f"{'=' * 60}")

    def on_prompt_found(self, prompt_text):
        self.current_prompt = prompt_text
        self.log_summary(f"\nCURRENT PROMPT:")
        self.log_summary(f"-" * 40)
        # Show first 500 chars
        display_prompt = prompt_text[:500] + "..." if len(prompt_text) > 500 else prompt_text
        self.log_summary(display_prompt)
        self.log_summary(f"-" * 40)

    def on_task_result(self, task_id, passed):
        status = "PASS" if passed else "FAIL"
        color = "\033[92m" if passed else "\033[91m"
        reset = "\033[0m"

        self.task_results.append((task_id, passed))

        # Console with color
        print(f"  [{color}{status}{reset}] {task_id}")

        # Summary file without color
        with open(SUMMARY_FILE, 'a') as f:
            f.write(f"  [{status}] {task_id}\n")

    def on_batch_complete(self, passed, total):
        pct = (passed / total * 100) if total > 0 else 0
        self.log_summary(f"\nBatch Result: {passed}/{total} passed ({pct:.1f}%)")
        self.generation_scores.append((self.current_generation, passed, total))

    def on_new_prompt_proposed(self, prompt_text):
        self.log_summary(f"\n*** NEW PROMPT PROPOSED ***")
        self.log_summary(f"-" * 40)
        display_prompt = prompt_text[:800] + "..." if len(prompt_text) > 800 else prompt_text
        self.log_summary(display_prompt)
        self.log_summary(f"-" * 40)

    def _flush_generation_summary(self):
        if not self.task_results:
            return
        passed = sum(1 for _, p in self.task_results if p)
        total = len(self.task_results)
        pct = (passed / total * 100) if total > 0 else 0
        self.log_summary(f"\nGeneration {self.current_generation} Summary: {passed}/{total} ({pct:.1f}%)")

    def print_final_summary(self):
        self.log_summary(f"\n{'=' * 60}")
        self.log_summary("FINAL SUMMARY")
        self.log_summary(f"{'=' * 60}")

        if self.generation_scores:
            self.log_summary("\nScore Progression:")
            for gen, passed, total in self.generation_scores:
                pct = (passed / total * 100) if total > 0 else 0
                bar = "#" * int(pct / 10) + "-" * (10 - int(pct / 10))
                self.log_summary(f"  Gen {gen}: [{bar}] {pct:.1f}% ({passed}/{total})")

        self.log_summary(f"\nCompleted: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")


def tail_file(filename):
    """Generator for reading new lines from a file."""
    try:
        with open(filename, 'r') as f:
            # Start from beginning to catch everything
            while True:
                line = f.readline()
                if not line:
                    time.sleep(0.3)
                    continue
                yield line
    except KeyboardInterrupt:
        return
    except FileNotFoundError:
        print(f"Waiting for log file {filename}...")
        while not os.path.exists(filename):
            time.sleep(1)
        yield from tail_file(filename)


def monitor_training(source_file=None):
    """Monitor GEPA training and create summary."""

    # Default to the background task output or training.log
    if source_file is None:
        # Try to find active output
        candidates = [
            "/tmp/claude/-Users-rohitsandadi-Downloads-GEPA-SWESMITH/tasks/bf09cbb.output",
            "gepa_results/logs/training.log"
        ]
        for c in candidates:
            if os.path.exists(c):
                source_file = c
                break

    if not source_file or not os.path.exists(source_file):
        print("No log file found. Please provide a log file path.")
        return

    print(f"Monitoring: {source_file}")
    print(f"Summary will be written to: {SUMMARY_FILE}")
    print("-" * 60)

    monitor = GEPAMonitor(source_file)

    # Patterns to detect
    patterns = {
        'generation': re.compile(r'Iteration (\d+):'),
        'task_start': re.compile(r'\[Task (\d+)/(\d+)\] ([^\s]+)'),
        'task_pass': re.compile(r' - .*PASS'),
        'task_fail': re.compile(r' - .*FAIL'),
        'batch_complete': re.compile(r'Batch complete: (\d+)/(\d+) passed'),
        'prompt_section': re.compile(r'system_prompt["\']?\s*:\s*["\'](.+?)["\']', re.DOTALL),
        'new_prompt': re.compile(r'Proposed new prompt|New candidate prompt|system_prompt.*?:.*?"([^"]{50,})"'),
        'bug_applied': re.compile(r'Bug patch applied'),
    }

    current_task_id = None
    in_prompt_capture = False
    prompt_buffer = []

    try:
        for line in tail_file(source_file):
            line_stripped = line.strip()

            # Detect generation/iteration
            match = patterns['generation'].search(line_stripped)
            if match:
                monitor.on_generation_start(int(match.group(1)))
                continue

            # Detect task start
            match = patterns['task_start'].search(line_stripped)
            if match:
                current_task_id = match.group(3)
                continue

            # Detect task pass
            if patterns['task_pass'].search(line_stripped) and current_task_id:
                monitor.on_task_result(current_task_id, True)
                current_task_id = None
                continue

            # Detect task fail
            if patterns['task_fail'].search(line_stripped) and current_task_id:
                monitor.on_task_result(current_task_id, False)
                current_task_id = None
                continue

            # Detect batch complete
            match = patterns['batch_complete'].search(line_stripped)
            if match:
                monitor.on_batch_complete(int(match.group(1)), int(match.group(2)))
                continue

            # Detect bug patch applied (good sign)
            if patterns['bug_applied'].search(line_stripped):
                print(f"  [OK] Bug patch applied")
                continue

    except KeyboardInterrupt:
        print("\n\nMonitoring stopped.")
        monitor.print_final_summary()
        print(f"\nFull summary saved to: {SUMMARY_FILE}")


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Monitor GEPA optimization")
    parser.add_argument("--file", "-f", help="Log file to monitor")
    args = parser.parse_args()

    monitor_training(args.file)
